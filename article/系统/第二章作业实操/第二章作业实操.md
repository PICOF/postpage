操作系统第二章的作业，集中记录一下

使用 makefile 自动编译运行程序：

```makefile
all:$(subst .c,exe,$(wildcard *.c))
%exe: %.c
	gcc -o $@ $< -lpthread
```

### 作业一

是一道考并发的题目，叫我复现以下内容：

![image-20220318164927618](image-20220318164927618.png)

```c
#include<stdlib.h>
#include<pthread.h>
#include<unistd.h>

int N=0;

void* plus(void *args) {
    for(int i=0;i<5;i++){
    	N++;
    	//printf("%d\n",N);
    	sleep(1);
    }
    return NULL;
}

void* tozero(void *args) {
    for(int i=0;i<5;i++){
	printf("%d\n",N);
	N=0;  
	sleep(1);
    }
    return NULL;
}

int main()
{
    pthread_t th1;
    pthread_t th2;
    
    pthread_create(&th1,NULL,plus,NULL);
    pthread_create(&th2,NULL,tozero,NULL);
    
    pthread_join(th1, NULL);
    pthread_join(th2, NULL);
    
    return 0;
}
```

![image-20220318164943973](image-20220318164943973.png)

### 作业二

首先看一下 wait，waitpid，以及 wait3、wait4 的执行方式

[点击就送屠龙宝刀](https://www.cnblogs.com/tongye/p/9558320.html)

#### wait()

```c
#include <sys/types.h>        // 提供类型 pid_t 的定义
#include <sys/wait.h>

pid_t wait(int *status);
```

调用 wait 会暂停（阻塞）当前进程，并开始自动分析是否存在前进程的某个子进程已经退出，如果找到了这样一个已经变成僵尸进程的子进程，wait 就会收集这个子进程的信息，并将其彻底销毁后返回；如果没有找到呢？它就会一直阻塞直到出现一个符合条件的僵尸进程

> #### status 参数
>
> 保存着子进程退出时的一些状态（包括 task_struct、thread_info及内核栈等）它是一个指向 int 类型的指针；
>
> 如果只是单纯想干掉僵尸不关心其数据，直接传 NULL 就好了
>
> #### wait 返回值
>
> 如果 wait() 调用成功，则会返回被收集子进程的进程ID；如果被调用进程没有子进程，则调用失败，返回 -1，这一点和 fork 有点相似

用 fork 开一个子进程可以验证一下

#### waitpid()

```c
#include <sys/types.h>
#include <sys/wait.h>

pid_t waitpid(pid_t pid,int *status,int options);
```

多了两个参数，实际就是在 wait 的基础之上加了一些条件：

> #### pid
>
> **pid < -1** ；等待进程组 ID 为 pid 绝对值的进程组中的任何子进程；
>
> **pid = -1** ；等待任何子进程，此时 waitpid() 相当于 wait()。
>
> ```c
> static inline pid_t wait(*status){
>     return waitpid(-1,*status,0);  
> }
> ```
>
> （wait 就是其特殊情况）
>
> **pid = 0** ；等待进程组 ID 与当前进程相同的任何子进程（也就是等待同一个进程组中的任何子进程）；
>
> **pid > 0** ；等待任何子进程 ID 为 pid 的子进程，只要指定的子进程还没有结束，waitpid() 就会一直等下去。
>
> #### option
>
> **WNOHANG**；如果没有任何已经结束了的子进程，则马上返回，不等待；
>
> **WUNTRACED**；如果子进程进入暂停执行的情况，则马上返回，但结束状态不予理会；
>
> 这两个条件可以一起用，用或连接
>
> **option = 0**；options 设为0，则 waitpid() 会一直等待，直到有进程退出

##### 三种返回值

- a）正常返回时，waitpid() 返回收集到的子进程的PID；
- b）如果设置了 WNOHANG，而调用 waitpid() 时，没有发现已退出的子进程可收集，则返回0；
- c）如果调用出错，则返回 -1，这时 error 会被设置为相应的值以指示错误所在。（当 pid 所指示的子进程不错在，或此进程存在，但不是调用进程的子进程， waitpid() 就会返回出错，这时 erron 被设置为 ECHILD）

#### wait3() 与 wait4()

```c
#include <sys/tpyes.h>
#include <sys/wait.h>

pid_t wait3(int *status,int options,struct rusage *rusage);
pid_t wait4(pid_t pid,int *status,int options,struct rusage *rusage);
```

他们有相似之处：**除了可以获得子进程状态信息外，还可以获得子进程的资源使用信息**

资源使用信息通过 **rusage** 传递。

wait3 没有 pid 参数，它等待所有子进程。wait4 则根据 pid 值确定等待规则，其等待规则与 waitpid 一样。

#### 关于代码段

![image-20220318214014448](image-20220318214014448.png)

child 实际上应该是 pid_t 类型的数据，但是底层也确实是 int，这里简化了。

child=fork()，最后 child 获取到的值就 0 或子进程 pid 或 -1。

这里没有进行错误判断，只进行了相应动作。

![image-20220318221516050](image-20220318221516050.png)