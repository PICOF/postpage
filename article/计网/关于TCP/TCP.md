今天本来是想花时间过一下 IO 多路复用的，但是没想到关注的俩老哥一起互发 TCP 详解，然后刚好这学期计网就要学这个，那就先把这块搞懂，爆鲨三次握手四次挥手等一系列知识点。

## [第一篇](https://mp.weixin.qq.com/s/Xb-kcSAF0q7awMfx6Dgp6A)

复习一下 OSI七层模型、TCP/IP 四层模型和五层体系结构：

<table>
    <tr>
    	<td><font size="5" face="幼圆">OSI 七层模型</font></td>
        <td><font size="5" face="幼圆">TCP/IP 四层模型</font></td>
        <td><font size="5" face="幼圆">五层体系结构</font></td>
    </tr>
    <tr>
    	<td>应用层</td>
        <td rowspan="3">应用层</td>
        <td rowspan="3">应用层</td>
    </tr>
    <tr>
    	<td>表示层</td>
    </tr>
    <tr>
    	<td>会话层</td>
    </tr>
    <tr>
    	<td>传输层</td>
        <td>传输层</td>
        <td>传输层</td>
    </tr>
    <tr>
        <td>网络层</td>
        <td>网络层</td>
        <td>网络层</td>
    </tr>
    <tr>
    	<td>数据链路层</td>
        <td rowspan="2">网络接口层</td>
        <td>数据链路层</td>
    </tr>
    <tr>
    	<td>物理层</td>
        <td>物理层</td>
    </tr>
</table>

> ##### 1、物理层：
>
> 主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。 　　
>
> ##### 2、数据链路层：
>
> 定义了如何让格式化数据以进行传输，以及如何让控制对物理介质的访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输。 　　
>
> ##### 3、网络层：
>
> 在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。 　　
>
> ##### 4、传输层：
>
> 定义了一些传输数据的协议和端口号（WWW端口80等），如： 
> TCP（transmission control protocol –传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据） 
> UDP（user datagram protocol–用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。 　　
>
> ##### 5、会话层：
>
> 通过运输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名） 　　
>
> ##### 6、表示层：
>
> 可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码（EBCDIC），而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。 　　
>
> ##### 7、应用层：
>
> 是最靠近用户的OSI层。这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务。

默写了一遍表格，发现自己居然都能背下来了，针不戳

而我们现在处于传输层，只需要利用下面的三层就可以实现数据传递

### 目标位置

只是发送，接收者根本不知道数据包具体交给哪一个进程，所以要为每一个进程编号对应，这就是所谓的 **端口号**

然后你在要发送的数据包上，增加了传输层的头部，**源端口号** 与 **目标端口号**。

![图片](1)

实际上这就已经接近 UDP 的实现了，当然 UDP 协议中不光有源端口和目标端口，还有数据包长度和校验值

### 丢包

每当某个网站上不去或者遇到一些网络通信失败的时候，很多人会打开命令行输入“ping”操作尝试查看是否丢包。这里的“包”就是指传输过程中发送的数据包

网络通讯中我们需要一个完善的机制，来判断是否存在丢包并补全

于是你设计了如下方案，A 每发一个包，都必须收到来自 B 的 **确认**（ACK），再发下一个，否则在一定时间内没有收到确认，就 **重传** 这个包。

![图片](2)

这就叫做 **停止等待协议**。没有确认接受我们永远不会发送下一个数据包，通信过程变得可靠。现在的通信过程又有了一个新的特征，**可靠交付**。

### 效率

停止等待协议虽然可靠，但是效率实在是太低。解决也比较简单——采用 **流水线** 的方式，一次性传输多个数据包

### 顺序问题

![图片](3)

以上的所有架构都基于顺序传递的设想之上，但是一旦数据包和ACK包在 **乱序流动**，他们之间对应关系就乱掉了。

所以为了解决这种问题，所有的数据包上都标明了**序号**（seq），而返回的 ACK 包上面都加上了 **确认号**（ack）

比如 B 发了一个确认号为 ack = 3，它不仅仅表示 A 发送的序号为 2 的包收到了，还表示 2 之前的数据包都收到了。这种方式叫**累计确认**或**累计应答**。

ACK 包的序号，实际上是指明下一个发送的包应该标记的序号，也就是收到的最后一个数据包的序号 seq + 1

### 流量问题

当发送方放松过多过快，而超过了接收方的接受能力时，可能就会出现问题。因此为了控制流量，需要让接收方和发送方知道彼此的接受能力

而用于描述自己接收能力的值，就叫做 **窗口大小**（win)。每次发包时都带上自己的窗口大小，就能实时表示自己的接收能力

![图片](4)

而具体控制方式，就有些像编程中的 **“滑动窗口”**，在窗口内发包，不可越界

![图片](5)

当 A 不断发送数据包时，**已发送的最后一个序号**就往右移动，直到碰到了窗口的上边界，此时 A 就无法继续发包，达到了流量控制。

但是当 A 不断发包的同时，A 也会收到来自 B 的确认包，此时**整个窗口**会往右移动，因此上边界也往右移动，A 就能发更多的数据包了。

![图片](6)

并且，在 B 返回的包中，如果改变了窗口长度，这个滑动窗口也会随之改变，并且遵循只改动右边界的规则，多扩少缩。

![图片](7)

![图片](8)

### 拥塞问题

实际上，上述情况只能算是一种理想状态下的假设，真实环境下发包还会受到网速的影响

拥塞控制与流量控制有些像，但流量控制是受 B 的接收能力影响，而拥塞控制是受 **网络环境** 的影响。

对于网络的承载能力，只能由发送方不断 **试探**，反复调整。

拥塞窗口的大小计算算法作为一个坑，日后再深入探究，现在只假设 **拥塞窗口的大小为  cwnd**，上一部分流量控制的 **滑动窗口的大小为 rwnd**，那么有：

<center><b>窗口大小 = min(cwnd, rwnd)</b></center>

就好像木桶效应一样，最终窗口大小只取决于最小项

### 连接问题（简单了解三次握手四次挥手）

#### 三次握手

其实在发送之前，我们还有一个最重要的任务——确立链接，我们这时就要借助于 **“三次挥手”**

> A：我准备好了(SYN)
>
> B：我知道了(ACK)，我也准备好了(SYN)
>
> A：我知道了(ACK)

![图片](9)

双方 **各自在内存中维护着自己的状态变量**，三次握手后，状态更新为 **连接已建立**（ESTABLISHED）。

这个双方建立连接的过程，就叫 **面向连接**

#### 四次挥手

当数据传输结束，需要断开连接时，四次挥手就登场了

> A：再见，我要关闭了(FIN)
>
> B：我知道了(ACK)
>
>    给 B 一段时间把自己的事情处理完...
>
> B：再见，我要关闭了(FIN)
>
> A：我知道了(ACK)

![图片](10)

### 总结

以上讲述的，就是 TCP 协议的核心思想，上面过程中需要传输的信息，就体现在 TCP 协议的头部，这里放上最常见的 TCP 协议头解读的图。

![图片](11)



<center><font size="4" color="blue"><b>TCP 是</b></font></center>
<center><font size="4" color="blue"><b>面向连接的、可靠的、基于字节流的</b></font></center>
<center><font size="4" color="blue"><b>传输层通信协议</b></font></center>

面向连接、可靠用上面文段就已经可以印证了，那什么叫做基于字节流呢？

> <b><font size="10">☣</font></b> 很简单，TCP 在建立连接时，需要告诉对方 MSS（最大报文段大小）。
>
> 也就是说，如果要发送的数据很大，在 TCP 层是需要按照 MSS 来切割成一个个的 **TCP 报文段** 的。
>
> 切割的时候我才不管你原来的数据表示什么意思，需要在哪里断句啥的，我就把它当成一串毫无意义的字节，在我想要切割的地方咔嚓就来一刀，标上序号，只要接收方再根据这个序号拼成最终想要的完整数据就行了。
>
> 在我 TCP 传输这里，我就把它当做一个个的**字节**，也就是基于字节流的含义了。

## [第二篇](https://mp.weixin.qq.com/s/Yq4mVDRyMmcc3bJpXOWEww)

如果说上面的文章语言接地气通俗易懂适合入门，那么第二篇则是语言严谨适合夯实基础，理清结构。

### TCP 头格式

![图片](12)

**序列号**：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。**用来解决网络包乱序问题。**

**确认应答号**：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。**用来解决不丢包的问题。**

**控制位：**

- *ACK*：该位为 `1` 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 `SYN` 包之外该位必须设置为 `1` 。
- *RST*：该位为 `1` 时，表示 TCP 连接中出现异常必须强制断开连接。
- *SYN*：该位为 `1` 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。
- *FIN*：该位为 `1` 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 `FIN` 位为 1 的 TCP 段。

> <font face="幼圆" color="black" size="5" style="background:rgb(227, 242, 253);padding:10px 10px;">为什么需要 TCP 协议？TCP 工作在哪一层？</font>

因为 IP 层不管你发送是否到位啊！也就是说，IP 层根本不可靠：**它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。**

所以为了保证数据包的可靠性，就需要上层 **传输层** 的 TCP 协议来保证。

因为 TCP 是一个工作在**传输层**的**可靠**数据传输的服务，它能确保接收端接收的网络包是**无损坏、无间隔、非冗余和按序的。**

> <font face="幼圆" color="black" size="5" style="background:rgb(227, 242, 253);padding:10px 10px;">什么是 TCP？</font>

![图片](13)

好图，之前就说过 TCP 是**面向连接的、可靠的、基于字节流**的传输层通信协议。

- **面向连接**：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；
- **可靠的**：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；
- **字节流**：消息是「没有边界」的，所以无论我们消息有多大都可以进行传输。并且消息是「有序的」，当「前一个」消息没有收到的时候，即使它先收到了后面的字节，那么也不能扔给应用层去处理，同时对「重复」的报文会自动丢弃。

> <font face="幼圆" color="black" size="5" style="background:rgb(227, 242, 253);padding:10px 10px;">什么是 TCP 连接？</font>

请注意，上一个问题指得仅仅只是一种协议，而这个问题则是探讨协议建立的连接

**定义：用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括Socket、序列号和窗口大小称为连接。**

|                   Socket                   |             序列号             |    窗口大小    |
| :----------------------------------------: | :----------------------------: | :------------: |
| 由 IP 地址传输层协议和端口号组成（找位置） | 用来解决乱序问题等（排序去重） | 用来做流量控制 |

> <font face="幼圆" color="black" size="5" style="background:rgb(227, 242, 253);padding:10px 10px;">如何唯一确定一个 TCP 连接呢？</font>

由 TCP 四元组确定唯一一个连接：

![图片](14)

源地址和目的地址的字段（32位）是在 IP 头部中，作用是通过 IP 协议发送报文给对方主机。

源端口和目的端口的字段（16位）是在 TCP 头部中，作用是告诉 TCP 协议应该把报文发给哪个进程。

> <font face="幼圆" color="black" size="5" style="background:rgb(227, 242, 253);padding:10px 10px;">有一个 IP 的服务器监听了一个端口，它的 TCP 的最大连接数是多少？</font>

服务器通常固定在某个本地端口上监听，等待客户端的连接请求。

因此，客户端 IP 和 端口是可变的，其理论值计算公式如下:
$$
最大\ TCP\ 连接数=客户端\ IP\ 数\times客户端端口数
$$
对 IPv4，客户端的 IP 数最多为 `2` 的 `32` 次方，客户端的端口数最多为 `2` 的 `16` 次方，也就是服务端单机最大 TCP 连接数，约为 `2` 的 `48` 次方。

然而实际上服务器连 10K+ 的访问量都是个要优化的问题，真这么能连也不至于被 DDOS 了

**是什么限制了连接数？**

- 首先主要是**文件描述符限制**，Socket 都是文件，所以首先要通过 `ulimit` 配置文件描述符的数目；
- 另一个是**内存限制**，每个 TCP 连接都要占用一定内存，操作系统的内存是有限的。

> <font face="幼圆" color="black" size="5" style="background:rgb(227, 242, 253);padding:10px 10px;">UDP 和 TCP 有什么区别呢？分别的应用场景是？</font>

UDP 不提供复杂的控制机制，利用 IP 提供面向**「无连接」**的通信服务。

### UDP 头部

![图片](15)

我超，这比 TCP 好看多了（指简单），头部只有 `8` 个字节（ 64 位）

- **目标和源端口**：主要是告诉 UDP 协议应该把报文发给哪个进程。
- **包长度**：该字段保存了 UDP 首部的长度跟数据的长度之和。
- **校验和**：校验和是为了提供可靠的 UDP 首部和数据而设计。

### TCP 和 UDP 区别

|                        |                             TCP                              |                             UDP                              |
| :--------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|        **连接**        |     TCP 是面向连接的传输层协议，传输数据前先要建立连接。     |               UDP 是不需要连接，即刻传输数据。               |
|      **服务对象**      |       TCP 是一对一的两点服务，即一条连接只有两个端点。       |           UDP 支持一对一、一对多、多对多的交互通信           |
|       **可靠性**       | TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按需到达。 |          UDP 是尽最大努力交付，不保证可靠交付数据。          |
| **拥塞控制、流量控制** |     TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。     | UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。  |
|      **首部开销**      | TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 `20` 个字节，如果使用了「选项」字段则会变长的。 |     UDP 首部只有 8 个字节，并且是固定不变的，开销较小。      |
|      **传输方式**      |         TCP 是流式传输，没有边界，但保证顺序和可靠。         |  UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。  |
|      **分片不同**      | TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。 | UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层，但是如果中途丢了一个分片，则就需要重传所有的数据包，这样传输效率非常差，所以通常 UDP 的报文应该小于 MTU。 |

UDP 就像个很容易坏档的游戏啊（笑

### TCP 和 UDP 应用场景

由于 TCP 是面向连接，能保证数据的 **可靠性交付**，因此经常用于：

- `FTP` 文件传输（FTP，即（File Transfer Protocol，*文件传输协议*），TCP/IP 协议组中的协议之一）
- `HTTP` / `HTTPS`

由于 UDP 面向无连接，它可以随时发送数据，再加上UDP本身的处理既 **简单又高效**，因此经常用于：

- 包总量较少的通信，如 `DNS` 、`SNMP` 等
- 视频、音频等多媒体通信
- 广播通信

> <font face="幼圆" color="black" size="5" style="background:rgb(227, 242, 253);padding:10px 10px;">为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？</font>

TCP 有 **可变长** 的「选项」字段，而 UDP 头部长度固定

> <font face="幼圆" color="black" size="5" style="background:rgb(227, 242, 253);padding:10px 10px;">为什么 UDP 头部有「包长度」字段，而 TCP 头部则没有「包长度」字段呢？</font>

$$
TCP/UDP\ 数据长度=IP\ 总长度-IP\ 首部长度-TCP/UDP\ 首部长度
$$

这样一来，实际上标不标包长度都可以经过计算得出，但是 **因为为了网络设备硬件设计和处理方便，首部长度需要是 `4`字节的整数倍。**所以包长度可能是来”凑四“的。

### TCP 连接建立

经典复习三次握手

![图片](16)

