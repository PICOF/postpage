之前假期闲着没事，花了两天把前端页面写了。清明节觉得差不多该写后端了，就从大概那个时候开始写，结果没想到前前后后写了整整五天，属实有点意外（尤其最后收尾收了我快两天）

## 项目完成过程中部分问题与相应解决方案

### SpringMVC

#### SpringMVC 代码结构

##### 关于 V 层

说实话，SpringMVC 后端耦合度较高，如果使用 jsp，后端耦合度就很高，如果非个人开发而是团队协作，就应当尽量避免 jsp 的使用。视图层主要负责面向用户的展示与渲染，像 jsp、html，甚至于是用于渲染的视图解析器（如 thymeleaf 等）都算是视图层

##### 关于 M 层

即 Model——数据模型层，在后端项目中主要起的一个存放数据的作用：比如我现在在程序运行中实例化一个对象并赋值，那么只要我们不以某种方式释放掉它，直到程序结束它都可以存放对应数据。在本项目中，使用 entity 包来存放，基本都是些 POJO

##### 关于 C 层

即控制器，用于处理用户请求，控制输出视图或做出回应

##### MVC 和三层架构

实际上，这并不是同一个东西：

- **MVC：(Model+View+Controller)(数据模型+视图+控制器）**
- **三层架构：(Presentation tier+Application tier+Date tier)(展现层+应用层+数据访问层）**

MVC 充其量不过是对应三层架构中的展现层罢了，它只能用于描述 Spring 的全局管理结构。因此用 MVC 来概括我们的后端工作往往是不全面不具体的。

项目代码中还有两个软件包——**Service** 以及 **DAO**，这两个才分别对应应用层和数据访问层

#### 关于路径的映射

在使用 Servlet 进行最底层的后端开发时有一个用于标识 Servlet 类对应路径的注解——即 WebServlet，而相关方法操作是通过 Servlet 类内部的 doGet 以及 doPost 实现的。

在 SpringMVC 中，摒弃了这种略显臃肿的模式，改为了使用 Controller 控制器来分配请求路径。

**示例代码：**

```java
@Controller
public class UserController {
    @Autowired
    private LoginService loginService;
    @Autowired
    private DataService dataService;
    @Autowired
    private Doctor doctor;
    @Autowired
    ObjectMapper objectMapper;
    @GetMapping("/login")
    public ModelAndView login(){
        return new ModelAndView("login.html");
    }
    @PostMapping("/login")
    public String judge(HttpSession session, @RequestParam("id") String id, @RequestParam("psw") String psw,@RequestParam("remember") String re){
        System.out.println("用户 "+id+" 登录系统！");
        if(loginService.loginbyWid(id,psw)||loginService.loginbyName(id,psw)){
            session.setAttribute("user",doctor.getWid());
            session.setAttribute("psw",psw);
            session.setAttribute("rem",re);
            return "redirect:/usertable";
        }else {
            return "redirect:/login";
        }
    }
    @PostMapping("/login/getinfo")
    public void getInfo(HttpSession session,HttpServletResponse response){
        try {
            if(session.getAttribute("rem")==null||((String)session.getAttribute("rem")).isEmpty()){
                response.getWriter().print("");
                return;
            }
            String psw=(String) session.getAttribute("psw");
            if(psw==null){
                response.getWriter().print("");
            }else {
                response.getWriter().print(psw);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    @GetMapping("/logout")
    public String logout(HttpSession session){
        session.removeAttribute("user");
        return "redirect:/login";
    }
    @GetMapping("/usertable")
    public ModelAndView userTable(){
        return new ModelAndView("frame.html");
    }
    @GetMapping("/usertable/main")
    public ModelAndView userTableMain(){
        return new ModelAndView("main.html");
    }
    @GetMapping("/usertable/bed")
    public void bed(HttpServletResponse response){
        try {
            response.setContentType("text/html;charset=utf-8");
            response.getWriter().print(objectMapper.writeValueAsString(dataService.getBed()));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    @GetMapping("/usertable/userid")
    public void userid(HttpServletResponse response,HttpSession session){
        try {
            response.setContentType("text/html;charset=utf-8");
            response.getWriter().print(session.getAttribute("user"));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    @GetMapping("/usertable/pre")
    public void preGet(HttpServletResponse response,@RequestParam("bid") int bid){
        try {
            response.getWriter().print(objectMapper.writeValueAsString(dataService.getPatientPre(bid)));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    @GetMapping("/usertable/arr")
    public void arrGet(HttpServletResponse response,@RequestParam("bid") int bid,@RequestParam("date") String date){
        try {
            response.setContentType("text/html;charset=utf-8");
            response.getWriter().print(dataService.getArrList(bid,date));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    @PostMapping("/usertable/arr")
    @ResponseBody
    public void arrSet(@RequestParam("bid") int bid,@RequestParam("date") String date,@RequestParam("data") String data){
        dataService.setArrList(bid,date,data);
    }
    @GetMapping("/usertable/personal")
    public ModelAndView userTablePersonal(){
        return new ModelAndView("personal.html");
    }
}
```

上面的这段代码中，反反复复出现了 **@GetMapping、@PostMapping** 的注解，实际上他们都是在 **@RequestMapping** 的基础之上限制了请求方法的映射处理。在 **@RequestMapping** 中有一个 **method** 属性，可以传入一个参数数组，即允许通过的请求方法，不传入默认全部

#### Model、ModelMap 和 ModelAndView

Model 产生模型数据，而视图View用于渲染模型数据

- **Model只是用来传输数据的，并不会进行业务的寻址。ModelAndView 却是可以进行业务寻址的（设置对应静态文件）**
- **Model 每一次请求可以自动创建，ModelAndView 却是需要手动实例化的**

##### Model

注意：如果在控制层上的方法声明了注解@ResponseBody ，则会直接将返回值输出到页面。 Model 是一个接口， 其实现类为ExtendedModelMap，继承了ModelMap类。

```java
public class ExtendedModelMap extends ModelMap implements Model
```

一般来说，可以用model来接收各种类型的数据，如果使用来接收一组数据List 》》那么这个时候的model实际上是ModelMap。

##### ModelMap

ModelMap对象主要用于传递控制方法处理数据到结果页面，也就是说我们把结果页面上需要的数据放到ModelMap对象中即可，
他的作用类似于request对象的setAttribute方法的作用: 用来在一个请求过程中传递处理的数据。
ModelMap或者Model通过addAttribute方法向页面传递参数.
其中addAttribute方法参数有多种方式：
常用的有：写在java代码中

```java
public ModelMap addAttribute(String attributeName, Object attributeValue){...}
public ModelMap addAttribute(Object attributeValue){...}
public ModelMap addAllAttributes(Collection<?> attributeValues) {...}
public ModelMap addAllAttributes(Map<String, ?> attributes){...}
```

然后在jsp页面上可以通过el表达式语言$attributeName或者是C标签库下的方法，来获取并展示modelmap中的数据。
**modelmap本身不能设置页面跳转的url地址别名或者物理跳转地址.**
那么我们可以通过控制器方法的字符串返回值来设置跳转url地址别名或者物理跳转地址。

比如这一段：

```java
@PostMapping("/login")
    public String judge(HttpSession session, @RequestParam("id") String id, @RequestParam("psw") String psw,@RequestParam("remember") String re){
        System.out.println("用户 "+id+" 登录系统！");
        if(loginService.loginbyWid(id,psw)||loginService.loginbyName(id,psw)){
            session.setAttribute("user",doctor.getWid());
            session.setAttribute("psw",psw);
            session.setAttribute("rem",re);
            return "redirect:/usertable";
        }else {
            return "redirect:/login";
        }
    }
```

返回了一个 String 值，即可设置跳转地址

添加模型数据用addObject; 设置视图setViewName; ModelAndView 对象有两个作用： (1). 设置转向地址,这也是ModelAndView和ModelMap的主要区别.设置方式如下所示:

```java
ModelAndView view = new ModelAndView("path:student");
```

或者通过setViewName方式:

```java
public void setViewName(String viewName){...}
```

(2). 将控制器方法中处理的结果数据传递到结果页面，也就是把在结果页面上需要的数据放到ModelAndView对象中即可，其作用类似于request对象的setAttribute方法的作用，用来在一个请求过程中传递处理的数据。通过以下方法向页面传递参数：

```java
public ModelAndView addObject(String attributeName, Object attributeValue){...}
public ModelAndView addObject(Object attributeValue){...}
```

在jsp中：也是可以通过el表达式语言a t t r i b u t e N a m e 或 者 C 标 签 库 的 attributeName或者C标签库的attributeName或者C标签库的{name } 来获取并展示ModelAndView中的数据。

看一下上面这一句：

```java
return new ModelAndView("personal.html");
```

实际上，就是返回一个新实例化的 ModelAndView 对象，使用构造方法赋予了 veiwName 属性

#### 在 SpringMVC 中获取 session 中的值

在实现登录功能时，一般做法都是往 session 里打值，然后取 session 中的值用于身份验证。

在这个过程中，必须要解决相关 session 的处理问题

##### 使用 HttpSession

最简单常规的方法，使用 setAttribute、getAttribute、removeAttribute 三个方法基本就足以正常实现功能了，这三个方法的参数都是名字索引

##### 使用 @SessionAttributes

这个注解标注于类之上，也就是我们的 Controller，不可以打在方法上

```java
//这里面的 name 就是之后要使用的参数
@SessionAttributes("name")
```

这个注解可以把参数存储到 session 中，进而可以实现在多个请求之间传递参数。它的作用雀食类似于 Session 的 Attribute 属性，但是请注意：**它的保存机制与 HttpSession 不相同！只用于临时的数据传递！并非长期保存**。使用 **SessionStatus** 方法可以清空数据，但是这个方法只对 @SessionAttributes 管用，对 HttpSession 的数据没有任何影响

使用该注解设置的参数，可以在当前的视图中直接通过 `request.getAttribute` 或 `session.getAttribute` 获取。而在后续请求中，则可以通过 `session.getAttribute` 或直接从 Model 中取出

##### 使用 @SessionAttribute

这个注解用于取出 session 中的数据并将其绑定到参数上：

```java
public String test2(@SessionAttribute("name") String name)
	{
		return name;
	}
```

不管你之前是用什么途径存入，这个注解都只管取出，也可取出 @SessionAttributes 的参数

#### @ResponseBody 和 @RequestBody

实际上是我在项目途中因为粗心写出来的一个错误解析：在不为控制器中方法体前加上 @ResponseBody 的情况下，我执行了 post 请求。然而尽管预先设定好的步骤执行了，却会返回一串奇怪的报错：找不到路径指定的渲染对象

这就怪死了，我那个路径压根就没传回任何路径映射，为什么他自己就给我渲染了？

原因很简单，使用 @RequestMapping 以及它的衍生注解后，返回值通常解析为跳转路径

### 前端部分

